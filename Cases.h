#ifndef CASES_H_INCLUDED
#define CASES_H_INCLUDED
// CSCI-115_Project.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include<chrono>
#include <string>
using namespace std;

using namespace std::chrono;			//shortcut to not type std::chrono::
int seedModifier = 1;					// for random num generator

void printArray(int arr[], int n)		//basic display array function
{
	cout << "[";
	for (int i = 0; i < n; i++)
	{
		cout << arr[i] << ",";
	}
	cout << "]\n";
}
void fillArrAve(int arr[], int size)		// fills array with n elements
{
	for (int i = 0; i < size; i++)
	{
		int a = rand() % (size-1);
		arr[i] = a;
	}
}
void fillArrBest(int arr[], int size,std::string sortName)
{
    if (sortName == "Insertion")
    {
        for (int i = 0; i < size; i++)
        {
            arr[i] = i;
        }
    }
    else if (sortName == "Selection")
    {
        for (int i = 0; i < size; i++)
        {
            arr[i] = i;
        }
        /*      Technically speaking the worst case = average case = best case since they are all equal to O(n^2)
        Therefore we can use a sorted, random, reverse sorted, half sorted, or any array for the best, worst, or average case but a sorted array would lead to less swaps*/
    }
    else if (sortName == "Bubble")
    {
        for (int i = 0; i < size; i++)
        {
            arr[i] = i;
        }
                /*      Technically speaking the worst case = average case = best case since they are all equal to O(n^2)
        Therefore we can use a sorted, random, reverse sorted, half sorted, or any array for the best, worst, or average case. Sorted array = less swaps*/
    }
    else if (sortName == "Merge")
    {
        for (int i = 0; i < size; i++)
        {
            arr[i] = i;
        }
        /*      Technically speaking the worst case = average case = best case since they are all equal to O(n^2)
        Therefore we can use a sorted, random, reverse sorted, half sorted, or any array for the best, worst, or average case*/
    }
    else if (sortName == "Quick")
    {
        int b = (size - 1);
        for (int i = 0; i < size; i++)
        {
            int a = rand() %b;
            arr[i] = a;
        }
        /*   The best case depends on the median element for partitioning everytime. Therefore we would get the median of the first, middle, and
                                        last element in the array, find the median, and use it as a pivot.                                      */
    }
    else if (sortName == "Heap")
    {
        int b = (size - 1);
        for (int i = 0; i < size; i++)
        {
            int a = rand() % b;
            arr[i] = a;
        }
        /*   Technically speaking the worst case = average case = best case since they are all equal to O(nlog(n)). Therefore we can use a sorted, random, reverse sorted,
           half sorted, or any array for the best, worst, or average case. After researching, some argue that that best time complexity generated by heapsort is when
          all the elements are identical and that would make the runtime almost linear. However, if using distinct elements the best case would be the same as the
                                                    average or worst case therefore we can use a random array.                                                          */

        /*Non-distinct elements
                for (int i = 0; i < size; i++)
        {
           arr[i]=1;
        }*/
    }
    else if (sortName == "Counting")
    {
        for (int i = 0; i < size; i++)
        {
            int a = rand() % 100;
            arr[i] = a;
        }
        /*   The best cases for counting sort is when the range inbetween numbers is small so we decided to sort numbers from 1-10 to keep the range small     */
    }
    else if (sortName == "Radix")
    {
        for (int i = 0; i < size; i++)
        {
            int a = rand() % 100;
            arr[i] = a;
        }
        /*   We will be combining radix sort with counting sort so the range will be kept in that 1-10 order but we will be using less digit spots so we want to go from 1-99     */

    }
    else
    {
        cout << "Invalid choice" << endl;
    }
}
void fillArrWorst(int arr[], int size, std::string sortName)
{
    if (sortName == "Insertion")
    {
        int temp1 = 0;
        for (int i = size; i > 0; i--)
        {
            arr[temp1] = i;
            temp1++;
        }
    }
    else if (sortName == "Selection")
    {
        int temp1 = 0;
        for (int i = size; i > 0; i--)
        {
            arr[temp1] = i;
            temp1++;
        }
        /*      Technically speaking the worst case = average case = best case since they are all equal to O(n^2)
            Therefore we can use a sorted, random, reverse sorted, half sorted, or any array for the best, worst, or average case*/
    }
    else if (sortName == "Bubble")
    {
        int temp1 = 0;
        for (int i = size; i > 0; i--)
        {
            arr[temp1] = i;
            temp1++;
        }
    }
    else if (sortName == "Merge")
    {
        int temp1 = 0;
        for (int i = size; i > 0; i--)
        {
            arr[temp1] = i;
            temp1++;
        }
        /*      Technically speaking the worst case = average case = best case since they are all equal to O(n^2)
            Therefore we can use a sorted, random, reverse sorted, half sorted, or any array for the best, worst, or average case*/
    }
    else if (sortName == "Quick")
    {
        for (int i = 0; i < size; i++)
        {
            if(i=0)
            {
                arr[i]=0;
            }
            int a = rand() % (size - 1);
            arr[i] = a;
        }
        /*   The best case depends on the median element for partitioning everytime. Therefore we would get the median of the first, middle, and
                                        last element in the array, find the median, and use it as a pivot.                                      */
    }
    else if (sortName == "Heap")
    {
        //Max heap
        int temp1 = 0;
        for (int i = size; i > 0; i--)
        {
            arr[temp1] = i;
            temp1++;
        }
        /*  Min heap
                for (int i = 0; i < size; i++)
        {
            int a = rand() % size - 1;
            arr[i] = a;
        }
        */
        /*   If we use max heap then going from reverse sorted array will give us the most moves or comparisons. Using min heap a sorted array would
                give us the most moves or comparisons but for the worst, average, and best cases they're equal.                                      */
    }
    else if (sortName == "Counting")
    {
        for (int i = 0; i < size; i++)
        {
            int a = rand() % (size-1);
            arr[i] = a;
        }
        /*   The worst cases for counting sort is when the range in between numbers is large so we decided to sort numbers from 1-1000 to keep the range large.
            A range too high would result in the sort not working at all     */
    }
    else if (sortName == "Radix")
    {
        for (int i = 0; i < size; i++)
        {
            int a = rand() % (size-1);
            arr[i] = a;
        }
        /*   We will be combining radix sort with counting sort so the range will be kept in that 1-10 order but we will be using more digit spots so we want to go from 1 to size-1     */
    }
    else
    {
        cout << "Invalid choice" << endl;
    }
}





#endif // CASES_H_INCLUDED
